package com.samsthenerd.beedev.language.core;

public class FEval {
    // returns a further reduced expression if it exists, or nothing if the expression is already reduced
//    public static Optional<FExpression> tryReduce(FExpression expr){
//        switch (expr){
//            // lambda and type abstraction are already reduced (i suppose we're just not worrying about eta reduction?)
//            case FFunc f -> {
//                return Optional.empty();
//            }
//            case FTypeAbs f -> {
//                return Optional.empty();
//            }
//            case FApp(FLambda(FType t, FVar vArg, FExpression body), FExpression arg) -> {
//
//            }
//        }
//    }
}
